
/**
 * -----------------------------------------------------------------------------
 *  Language Syntax Summary
 * -----------------------------------------------------------------------------
 */

%include grammar/lexemes                // Lexeme/Token Definitions
%include grammar/common                 // Common Utils

%include grammar/literals               // Literal Definitions

%include grammar/template-params        // T<out TArg: Type, in TArg2: Type>
%include grammar/template-arguments     // T<TArg, TArg2>

%include grammar/callable               // callable(mixed): void
%include grammar/function               // function name(mixed): void
%include grammar/method                 // public function name(mixed): void

%include grammar/shape-fields           // array { key: int, ...<TKey, TValue> }
%include grammar/named-type             // Map<int<0, max>, non-empty-string>

%include grammar/inheritance            // extends Class<T>
                                        // extends Interface<T>, Interface2<T>
                                        // implements Interface<T>, Interface2<T>

%include grammar/namespace              // namespace Name\Any;
%include grammar/class-like             // class Example {}
                                        // interface Example {}
                                        // trait Example {}
%include grammar/type                   // type T = string | int

%pragma root Document

#Document
  : Namespace()
  | DefinitionStatement()*
  ;

DefinitionStatement
  : TypeDefinition()
  | ClassDefinition()
  | InterfaceDefinition()
  | TraitDefinition()
  ;

/**
 * -----------------------------------------------------------------------------
 *  Type Statement
 * -----------------------------------------------------------------------------
 *
 *  Constant references to external definitions or
 *  describe the type in some way.
 *
 */

#Type
  : LogicalType()
  ;

/**
 * -----------------------------------------------------------------------------
 *  Logical Statements
 * -----------------------------------------------------------------------------
 *
 *  Logical statements denote union or intersection types, like:
 *  - A | B | C - for union type references.
 *  - A & B & C - for intersection type references.
 *
 */

LogicalType
  : UnionType()
  ;

UnionType -> {
    if (\count($children) === 2) {
        return new Node\Stmt\UnionTypeNode($children[0], $children[1]);
    }

    return $children;
}
  : IntersectionType() (::T_OR:: UnionType())?
  ;

IntersectionType -> {
    if (\count($children) === 2) {
        return new Node\Stmt\IntersectionTypeNode($children[0], $children[1]);
    }

    return $children;
}
  : UnaryType() (::T_AMP:: IntersectionType())?
  ;

/**
 * -----------------------------------------------------------------------------
 *  Unary Statements
 * -----------------------------------------------------------------------------
 *
 *  Unary statements denote terminal types, like:
 *  - A - for type reference.
 *  - ?A - for nullable type reference.
 *  - 'some' - for string literal reference.
 *  - etc...
 *
 */

UnaryType
  : PrefixedNullableType()
  ;

// stmt = ?Type
PrefixedNullableType -> {
    if (\is_array($children)) {
        return new Node\Stmt\NullableTypeNode($children[1]);
    }

    return $children;
}
  : <T_NULLABLE> TypesList()
  | SuffixedNullableType()
  ;

// stmt = Type?
SuffixedNullableType -> {
    if (\count($children) > 1) {
        $result = new Node\Stmt\NullableTypeNode($children[0]);
        $result->offset = $children[1]->getOffset();

        return $result;
    }

    return $children[0];
}
  : TypesList() <T_NULLABLE>?
  ;

TypesList -> {
    $statement = \array_shift($children);

    for ($i = 0, $length = \count($children); $i < $length; ++$i) {
        $statement = new Node\Stmt\TypesListNode($statement);
        $statement->offset = $children[$i]->getOffset();
    }

    return $statement;
}
  : PrimaryType() (
      <T_SQUARE_BRACKET_OPEN>
      ::T_SQUARE_BRACKET_CLOSE::
    )*
  ;

PrimaryType
  : ::T_PARENTHESIS_OPEN:: Type() ::T_PARENTHESIS_CLOSE::
  | Literal()
  | CallableType()
  | NamedType()
  ;
