
/**
 * -----------------------------------------------------------------------------
 *  Language Syntax Summary
 * -----------------------------------------------------------------------------
 */

%include grammar/lexemes
%include grammar/literals
%include grammar/template
%include grammar/shape
%include grammar/common
%include grammar/callable
%include grammar/typedef

%pragma root Statement

/**
 * -----------------------------------------------------------------------------
 *  Type Statement
 * -----------------------------------------------------------------------------
 *
 *  Constant references to external definitions or
 *  describe the type in some way.
 *
 */

#TypeStatement
  : LogicalTypeStatement()
  ;

// Binary statements/expressions

LogicalTypeStatement
  : UnionTypeStatement()
  ;

UnionTypeStatement -> {
    if (\count($children) === 2) {
        return new Node\Stmt\Type\UnionTypeNode($children[0], $children[1]);
    }

    return $children;
}
  : IntersectionTypeStatement() (::T_OR:: UnionTypeStatement())?
  ;

IntersectionTypeStatement -> {
    if (\count($children) === 2) {
        return new Node\Stmt\Type\IntersectionTypeNode($children[0], $children[1]);
    }

    return $children;
}
  : UnaryTypeStatement() (::T_AMP:: IntersectionTypeStatement())?
  ;

// Unary statements/expressions

UnaryTypeStatement
  : PrefixedNullableTypeStatement()
  ;

// stmt = ?Type
PrefixedNullableTypeStatement -> {
    if (\is_array($children)) {
        return new Node\Stmt\Type\NullableTypeNode($children[1]);
    }

    return $children;
}
  : <T_NULLABLE> TypesListStatement()
  | SuffixedNullableTypeStatement()
  ;

// stmt = Type?
SuffixedNullableTypeStatement -> {
    if (\count($children) > 1) {
        $result = new Node\Stmt\Type\NullableTypeNode($children[0]);
        $result->offset = $children[1]->getOffset();

        return $result;
    }

    return $children[0];
}
  : TypesListStatement() <T_NULLABLE>?
  ;

TypesListStatement -> {
    $statement = \array_shift($children);

    for ($i = 0, $length = \count($children); $i < $length; ++$i) {
        $statement = new Node\Stmt\Type\TypesListNode($statement);
        $statement->offset = $children[$i]->getOffset();
    }

    return $statement;
}
  : PrimaryTypeStatement() (
      <T_SQUARE_BRACKET_OPEN>
      ::T_SQUARE_BRACKET_CLOSE::
    )*
  ;

// Primary

PrimaryTypeStatement
  : ::T_PARENTHESIS_OPEN:: TypeStatement() ::T_PARENTHESIS_CLOSE::
  | Literal()
  | CallableTypeStmt()
  | NamedTypeStmt()
  ;



