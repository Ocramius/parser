
ShapeFields -> {
    if ($children === []) {
        return new Node\Type\Shape\FieldsListNode();
    }

    if (!$children[0] instanceof \ArrayObject) {
        return new Node\Type\Shape\FieldsListNode([], false);
    }

    return new Node\Type\Shape\FieldsListNode(
        $children[0]->getArrayCopy(),
        \count($children) !== 2,
    );
}
  : ::T_BRACE_OPEN::
      ( (ShapeFieldsList() (::T_COMMA:: <T_ELLIPSIS>)? ::T_COMMA::?)
      | <T_ELLIPSIS> ::T_COMMA::? )?
    ::T_BRACE_CLOSE::
  ;

IsSealed -> { return $children === []; }
  : <T_ELLIPSIS>?
  ;

ShapeFieldsList -> {
    return new \ArrayObject($children);
}
  : ShapeField() (::T_COMMA:: ShapeField())*
  ;

ShapeField
  : IdentifiedField()
  | AnonymousField()
  ;

IdentifiedField -> {
    $name = $children[0];
    $value = \array_pop($children);

    // In case of "nullable" suffix defined
    $optional = \count($children) === 2;

    return match (true) {
        $name instanceof Node\Literal\IntLiteralNode
            => new Node\Type\Shape\NumericFieldNode($name, $value, $optional),
        $name instanceof Node\Literal\StringLiteralNode
            => new Node\Type\Shape\StringNamedFieldNode($name, $value, $optional),
        default => new Node\Type\Shape\NamedFieldNode($name, $value, $optional),
    };
}
  : ShapeKey() (<T_NULLABLE>)? ::T_COLON:: ShapeValue()
  ;

AnonymousField -> {
    return new Node\Type\Shape\FieldNode($children[0]);
}
  : ShapeValue()
  ;

ShapeKey
  : Identifier()
  | IntLiteral()
  | StringLiteral()
  ;

ShapeValue
  : TypeStatement()
  ;
