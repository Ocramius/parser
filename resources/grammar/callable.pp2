
CallableTypeStmt -> {
    $name = \array_shift($children);

    $arguments = isset($children[0]) && $children[0] instanceof Node\Type\Callable\ArgumentsListNode
        ? \array_shift($children)
        : new Node\Type\Callable\ArgumentsListNode();

    return new Node\Type\CallableTypeNode(
        name: $name,
        arguments: $arguments,
        type: isset($children[0]) ? $children[0] : null,
    );
}
  : Name()
    ::T_PARENTHESIS_OPEN::
        CallableArguments()?
    ::T_PARENTHESIS_CLOSE::
    CallableReturnType()?
  ;

CallableArguments -> {
    return new Node\Type\Callable\ArgumentsListNode($children);
}
  : OptionalCallableArgument() (::T_COMMA:: OptionalCallableArgument())* ::T_COMMA::?
  ;

OptionalCallableArgument -> {
    if (!isset($children[1])) {
        return $children[0];
    }

    return new Node\Type\Callable\OptionalArgumentNode($children[0]);
}
  : NamedCallableArgument() <T_EQ>?
  ;

NamedCallableArgument -> {
    if (\count($children) === 1) {
        return $children[0];
    }

    return new Node\Type\Callable\NamedArgumentNode($children[1], $children[0]);
}
  : VariadicCallableArgument() VariableLiteral()?
  ;

VariadicCallableArgument -> {
    if (!isset($children[1])) {
        return $children[0];
    }

    if ($children[0] instanceof Node\Type\Callable\ArgumentNodeInterface) {
        return new Node\Type\Callable\VariadicArgumentNode($children[0]);
    }

    return new Node\Type\Callable\VariadicArgumentNode($children[1]);
}
  : <T_ELLIPSIS> OutputCallableArgument()   // Prefixed variadic argument (Psalm format)
  | OutputCallableArgument() <T_ELLIPSIS>?  // Suffixed variadic argument (PhpStan + Psalm)
  ;

OutputCallableArgument -> {
    $argument = new Node\Type\Callable\ArgumentNode($children[0]);

    if (\count($children) === 1) {
        return $argument;
    }

    return new Node\Type\Callable\OutArgumentNode($argument);
}
  : TypeStatement() <T_AMP>?
  ;

CallableReturnType
  : ::T_COLON:: TypeStatement()
  ;
